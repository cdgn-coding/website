---
title: "Estructura de datos Trie"
slug: "estructura-de-datos-trie"
date: "2025-02-02"
toc: false
readTime: true
autonumber: true
math: true
showTags: false
hideBackToTop: true
draft: false
description: "Explicaciones breves y fragmentos de código JavaScript para tener a mano al resolver problemas y para un repaso rápido antes de entrevistas de programación"
tags: ["estructuras-de-datos"]
draft: true
---

La estructura de datos Trie es una herramienta fundamental en la computación moderna. Se usa para la búsqueda eficiente de palabras, autocompletado, corrección ortográfica y almacenamiento de diccionarios.

## Arboles

Para entender los Tries, primero debemos repasar los árboles, una de las estructuras más utilizadas en la informática. Un árbol es una estructura jerárquica en la que cada nodo puede tener múltiples hijos.

Un ejemplo intuitivo de un árbol es el organigrama de una empresa.

```mermaid
graph TD;
    Director_General[Director General] --> VP_Ingenieria[VP Ingenieria];
    Director_General --> VP_Ventas[VP Ventas];
    VP_Ingenieria --> Gerente_Ingenieria1[Gerente Ingenieria 1];
    VP_Ingenieria --> Gerente_Ingenieria2[Gerente Ingenieria 2];
    VP_Ventas --> Gerente_Ventas1[Gerente Ventas 1];
    VP_Ventas --> Gerente_Ventas2[Gerente Ventas 2];
    Gerente_Ingenieria1 --> Desarrollador1[Desarrollador 1];
    Gerente_Ingenieria1 --> Desarrollador2[Desarrollador 2];
    Gerente_Ventas1 --> Vendedor1[Vendedor 1];
    Gerente_Ventas1 --> Vendedor2[Vendedor 2];
```

Los árboles sirven para modelar muchos problemas en la computación, este artículo hablará de un tipo de árbol particular llamado Trie.

## ¿Qué es un Trie?

Un Trie (también llamado árbol de prefijos o radix tree) es una estructura de datos en forma de árbol donde cada nodo representa un carácter de una palabra.

Al recorrer el Trie desde la raíz hasta un nodo hoja, se puede reconstruir una palabra completa. Cada nivel del Trie representa una letra en la secuencia de una palabra, lo que lo hace útil para aplicaciones de búsqueda y procesamiento de texto.

```mermaid
graph TD;
    B[G] --> C[A];
    B[G] --> H[O];
    C[A] --> D[T];
    C[A] --> E[L];
    D[T] --> F[O];
    E[L] --> G[L];
    G[L] --> I[O];
    H[O] --> J[M];
    J[M] --> K[A];
```

## Autocompletado

El autocompletado es una funcionalidad común en aplicaciones modernas. Una forma intuitiva de implementarla es tener una lista de palabras y comparar el prefijo introducido por el usuario con cada palabra de la lista.

Este enfoque tiene un problema: si el diccionario es muy grande, la búsqueda puede ser muy lenta.

El Trie es ideal para autocompletado porque almacena palabras de manera jerárquica, permitiendo encontrar rápidamente todas las palabras que comienzan con un prefijo dado.

Cuando un usuario escribe las primeras letras de una palabra, el Trie puede recorrer la estructura hasta el nodo correspondiente y devolver todas las posibles continuaciones sin necesidad de recorrer todo el diccionario.

<div class="trie-demo">
  <input 
    type="text" 
    id="trieInput" 
    placeholder="Escribe para ver el Trie..."
    class="w-full p-2 border rounded"
  />
  <div id="suggestions">
    <ul id="suggestionsList"></ul>
  </div>
  <div id="trieGraph"></div>
</div>

<script type="module">
import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
// Clase para el nodo del Trie
class TrieNode {
  constructor() {
    this.children = new Map();
    this.isEndOfWord = false;
  }
}

// Clase principal del Trie
class Trie {
  constructor() {
    this.root = new TrieNode();
  }

  insert(word) {
    let current = this.root;
    for (const char of word) {
      if (!current.children.has(char)) {
        current.children.set(char, new TrieNode());
      }
      current = current.children.get(char);
    }
    current.isEndOfWord = true;
  }

  // Busca un prefijo y retorna el último nodo
  searchPrefix(prefix) {
    let current = this.root;
    let found = true;
    for (const char of prefix) {
      if (!current.children.has(char)) {
        found = false;
        break;
      }
      current = current.children.get(char);
    }
    return { node: current, found };
  }

  // Obtiene todas las palabras del Trie para visualización
  getAllPaths(node = this.root, prefix = '', paths = []) {
    if (node.isEndOfWord) {
      paths.push(prefix);
    }
    
    for (const [char, childNode] of node.children) {
      this.getAllPaths(childNode, prefix + char, paths);
    }
    
    return paths;
  }

  // Genera el diagrama Mermaid
  generateMermaidDiagram(searchPrefix = '') {
    let diagram = 'graph TD;\n';
    let visited = new Set();
    
    const traverse = (node = this.root, path = '') => {
      for (const [char, childNode] of node.children) {
        const currentPath = path + char;
        const nodeId = currentPath || 'root';
        const parentId = path || 'root';
        
        if (!visited.has(nodeId)) {
          // Agregar nodo
          diagram += `    ${parentId}["${path ? path.slice(-1) : 'root'}"] --> ${nodeId}["${char}"];\n`;
          
          // Resaltar nodos que coinciden con el prefijo
          if (searchPrefix && currentPath.startsWith(searchPrefix)) {
            diagram += `    style ${nodeId} fill:#ff9,stroke:#f66;\n`;
          }
          
          visited.add(nodeId);
          traverse(childNode, currentPath);
        }
      }
    };

    traverse();
    return diagram;
  }

  // Método para obtener sugerencias de autocompletado
  getSuggestions(prefix) {
    const { node, found } = this.searchPrefix(prefix);
    if (!found) return [];
    
    const suggestions = [];
    this.getAllPaths(node, prefix, suggestions);
    return suggestions;
  }
}

// Inicializar el Trie con palabras
const trie = new Trie();
const words = ['gato', 'gallo', 'goma', 'perro', 'pato', 'pez', 'gata', 'gallina', 'gorila', 'gorra'];
words.forEach(word => trie.insert(word));

function updateTrie() {
  const prefix = document.getElementById('trieInput').value.toLowerCase();
  const diagram = trie.generateMermaidDiagram(prefix);
  
  // Mostrar sugerencias
  const suggestions = trie.getSuggestions(prefix);

  if (suggestions.length > 0 && prefix.length > 0) {
    const suggestionsDiv = document.getElementById('suggestions');
    suggestionsDiv.innerHTML = `
      <div class="text-sm text-gray-600">Sugerencias: ${suggestions.join(', ')}</div>
    `;
  } else {
    suggestionsDiv.innerHTML = '';
  }
  
  // Renderizar el diagrama
  const element = document.getElementById('trieGraph');
  element.innerHTML = '';
  mermaid.render('trie-diagram', diagram).then(result => {
    const svg = result.svg;
    element.innerHTML = svg;
  });
}

// Inicializar Mermaid y agregar listener
mermaid.initialize({ startOnLoad: true });
document.getElementById('trieInput').addEventListener('input', updateTrie);
updateTrie();
</script>

<style>
.trie-demo {
  margin: 2rem 0;
  padding: 1rem;
  border: 1px solid #ddd;
  border-radius: 4px;
}
#trieGraph svg {
  width: 100%;
  height: 100%;
}
#suggestions {
  padding: 0.5rem;
  border-radius: 4px;
  background-color: #f8f9fa;
}
#suggestionsList {
  list-style-type: none;
  padding: 0;
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
}
</style>

## Corrección ortográfica

## Diccionarios

